// KRPC - Bencoded dictionaries sent over UDP without retries
// dictionary with 3 keys common in all msgs and additional keys if needed
// t - transaction id
//      -> generated by the querying node and is echoed in the response
//      -> useful for correlation multiple queries to same node
//      -> short string of binary numbers, 2 characters are enough
// y - single char describing msg type (q for query, r for response, e for error)
// v - versioning (not needed rn)
//
// query:
//      key q - string value containing method name of query
//      key a - named arguments dict
// responses - key r, value is dictionary containing named return values
// errors - key e is a list, first element error code, second element string containing the error message

enum KrpcError {
    // 201
    GenericError,
    // 202
    ServerError,
    // 203
    ProtocolError,
    // 204
    MethodUnknown,
}

// All queries have id key and value containing node id of querying node
// Responses have same for responding node
enum DhtMessageType {
    // q = "ping", id = 20 byte string source id
    // Query = {"t":"aa", "y":"q", "q":"ping", "a":{"id":"abcdefghij0123456789"}}
    // Response = {"t":"aa", "y":"r", "r": {"id":"mnopqrstuvwxyz123456"}}
    Ping,
    // q = "find_node", id = source node id, target = target node id
    // return compact node info OR k closest good nodes in its own routing table
    FindNode,
    // q = "get_peers", id = source, info_hash = basically key id
    // If queried node has the val, return in "values" list
    // Else return "nodes" list with K nodes closest to infohash.
    // "token" short binary string included in return value TODO: what is this for?
    // format:
    // arguments:  {"id" : "<querying nodes id>", "info_hash" : "<20-byte infohash of target torrent>"}
    // response: {"id" : "<queried nodes id>", "token" :"<opaque write token>", "values" : ["<peer 1 info string>", "<peer 2 info string>"]}
    // or: {"id" : "<queried nodes id>", "token" :"<opaque write token>", "nodes" : "<compact node info>"}
    GetPeers,
    // q = "announce_peer", id = source, info_hash = key, port = udp port, token = received in response to previous get_peers query
    // response: {"id" : "<queried nodes id>"}
    AnnouncePeer,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcRequest {
    t: String,
    y: String,

    q: String,
    a: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcSuccessResponse {
    t: String,
    y: String,

    r: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcErrorResponse {
    t: String,
    y: String,

    e: (u8, String),
}

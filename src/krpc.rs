// KRPC - Bencoded dictionaries sent over UDP without retries
// dictionary with 3 keys common in all msgs and additional keys if needed
// t - transaction id
//      -> generated by the querying node and is echoed in the response
//      -> useful for correlation multiple queries to same node
//      -> short string of binary numbers, 2 characters are enough
// y - single char describing msg type (q for query, r for response, e for error)
// v - versioning (not needed rn)
//
// query:
//      key q - string value containing method name of query
//      key a - named arguments dict
// responses - key r, value is dictionary containing named return values
// errors - key e is a list, first element error code, second element string containing the error message

use tokio::net::UdpSocket;

enum KrpcError {
    // 201
    GenericError,
    // 202
    ServerError,
    // 203
    ProtocolError,
    // 204
    MethodUnknown,
}

// All queries have id key and value containing node id of querying node
// Responses have same for responding node
enum DhtMessageType {
    // q = "ping", id = 20 byte string source id
    // Query = {"t":"aa", "y":"q", "q":"ping", "a":{"id":"abcdefghij0123456789"}}
    // Response = {"t":"aa", "y":"r", "r": {"id":"mnopqrstuvwxyz123456"}}
    Ping,
    // q = "find_node", id = source node id, target = target node id
    // return compact node info OR k closest good nodes in its own routing table
    FindNode,
    // q = "get_peers", id = source, info_hash = basically key id
    // If queried node has the val, return in "values" list
    // Else return "nodes" list with K nodes closest to infohash.
    // "token" short binary string included in return value TODO: what is this for?
    // format:
    // arguments:  {"id" : "<querying nodes id>", "info_hash" : "<20-byte infohash of target torrent>"}
    // response: {"id" : "<queried nodes id>", "token" :"<opaque write token>", "values" : ["<peer 1 info string>", "<peer 2 info string>"]}
    // or: {"id" : "<queried nodes id>", "token" :"<opaque write token>", "nodes" : "<compact node info>"}
    GetPeers,
    // q = "announce_peer", id = source, info_hash = key, port = udp port, token = received in response to previous get_peers query
    // response: {"id" : "<queried nodes id>"}
    AnnouncePeer,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcRequest {
    t: String,
    y: String,

    q: String,
    a: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcSuccessResponse {
    t: String,
    y: String,

    r: HashMap<String, String>,
}

#[derive(Serialize, Deserialize, PartialEq, Eq, Debug)]
struct KrpcErrorResponse {
    t: String,
    y: String,

    e: (u8, String),
}

pub struct Krpc {
    socket: UdpSocket,
}

impl Krpc {
    async fn init() -> Self {
        let socket = Arc::new(
            UdpSocket::bind(format!("127.0.0.1:{}", args.udp_port))
                .await
                .unwrap(),
        );

        Self { socket }
    }

    async fn listen(&self) {
        loop {
            let mut buf = [0; 2048];
            let (len, addr) = socket.recv_from(&mut buf).await.unwrap();

            handle_krpc_call(&routing_table, &peer_store, &self.socket, &buf, len, addr).await;
        }
    }
}

// REFACTOR!!!
async fn handle_krpc_call(buf: &[u8; 2048], len: usize, addr: SocketAddr) {
    let query: KrpcRequest = serde_bencode::from_bytes(&buf[..len]).unwrap();

    match query.q.as_str() {
        "ping" => {
            let routing_table = routing_table.lock().unwrap();
            let mut return_values = HashMap::new();
            return_values.insert("id".into(), routing_table.my_node.id.to_string());

            let response = KrpcSuccessResponse {
                y: "r".into(),
                t: query.t,
                r: return_values,
            };
            let response = serde_bencode::to_bytes(&response).unwrap();
            socket.send_to(&response, addr).await.unwrap();
        }
        "find_node" => {
            let source_id = query.a.get("id").unwrap().parse().unwrap();
            let source_node = Node {
                id: source_id,
                ip: addr.ip(),
                port: addr.port(),
            };
            routing_table.lock().unwrap().upsert_node(source_node);
            let target_node_id = query.a.get("target").unwrap().parse().unwrap();
            let k_closest_nodes = get_nodes(routing_table, target_node_id);
            let compact_node_info = k_closest_nodes
                .iter()
                .map(|node| node.get_node_compact_format())
                .collect::<Vec<String>>()
                .concat();

            let mut return_values = HashMap::new();
            return_values.insert(
                "id".into(),
                routing_table.lock().unwrap().my_node.id.to_string(),
            );
            return_values.insert("nodes".into(), compact_node_info);

            let response = KrpcSuccessResponse {
                y: "r".into(),
                t: query.t,
                r: return_values,
            };
            let response = serde_bencode::to_bytes(&response).unwrap();
            socket.send_to(&response, addr).await.unwrap();
        }
        "get_peers" => {
            let source_id = query.a.get("id").unwrap().parse().unwrap();
            let source_node = Node {
                id: source_id,
                ip: addr.ip(),
                port: addr.port(),
            };
            routing_table.lock().unwrap().upsert_node(source_node);

            let info_hash = query.a.get("info_hash").unwrap();

            let mut return_values = HashMap::new();
            return_values.insert(
                "id".into(),
                routing_table.lock().unwrap().my_node.id.to_string(),
            );

            let peer_store_guard = peer_store.lock().unwrap();
            let peers = peer_store_guard.get(info_hash);
            if let Some(peers) = peers {
                // values
                let values = peers
                    .iter()
                    .map(|peer| peer.get_peer_compact_format())
                    .collect::<Vec<String>>()
                    .concat();
                return_values.insert("values".into(), values); // this won't work rn
            } else {
                // nodes
                let k_closest_nodes = get_nodes(routing_table, info_hash.parse().unwrap());
                let compact_node_info = k_closest_nodes
                    .iter()
                    .map(|node| node.get_node_compact_format())
                    .collect::<Vec<String>>()
                    .concat();
                return_values.insert("nodes".into(), compact_node_info);
            }

            // generate token
            // hash ip + secret
            let mut hasher = Sha1::new();
            if let IpAddr::V4(v4addr) = addr.ip() {
                hasher.update(v4addr.octets());
            }
            hasher.update(*routing_table.lock().unwrap().secret.lock().unwrap());
            let token = format!("{:x}", hasher.finalize());

            return_values.insert("token".into(), token);

            let response = KrpcSuccessResponse {
                y: "r".into(),
                t: query.t,
                r: return_values,
            };
            let response = serde_bencode::to_bytes(&response).unwrap();
            socket.send_to(&response, addr).await.unwrap();
        }
        "announce_peer" => {
            let info_hash = query.a.get("info_hash").unwrap();
            let port = query.a.get("port").unwrap();
            let token = query.a.get("token").unwrap();

            let source_id = query.a.get("id").unwrap().parse().unwrap();
            let source_node = Node {
                id: source_id,
                ip: addr.ip(),
                port: addr.port(),
            };
            routing_table
                .lock()
                .unwrap()
                .upsert_node(source_node.clone());

            let mut hasher = Sha1::new();
            if let IpAddr::V4(querying_ip) = addr.ip() {
                hasher.update(querying_ip.octets());
            }
            hasher.update(*routing_table.lock().unwrap().secret.lock().unwrap());

            let target_token = format!("{:x}", hasher.finalize());

            if *token != target_token {
                // send failure message
            }

            peer_store
                .lock()
                .unwrap()
                .entry(info_hash.clone())
                .or_default()
                .push(source_node);

            let mut return_values: HashMap<String, String> = HashMap::new();
            return_values.insert(
                "id".to_string(),
                routing_table.lock().unwrap().my_node.ip.to_string(),
            );

            let response = KrpcSuccessResponse {
                y: "r".into(),
                t: query.t,
                r: return_values,
            };

            let response = serde_bencode::to_bytes(&response).unwrap();
            socket.send_to(&response, addr).await.unwrap();
        }
        _ => {}
    }
}
